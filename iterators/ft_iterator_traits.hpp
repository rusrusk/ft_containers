#ifndef ITERATOR_TRAITS_HPP
# define ITERATOR_TRAITS_HPP

#include <iostream>

/////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////
//***ITERATOR TRAITS CLASS***//////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////
namespace ft
{

	//ITERATOR CATEGORIES/TAGS. Each tag is an empty type
	//iterator tags are used to indicate the capabilities of iterators
	struct input_iterator_tag{};
	struct output_iterator_tag {};
	struct forward_iterator_tag			: public input_iterator_tag {};
	struct bidirectional_iterator_tag 	: public forward_iterator_tag {};
	struct random_access_iterator_tag 	: public bidirectional_iterator_tag {};


/////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////
//***ITERATOR TRAITS***//////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////
	//template struct is used to extract info about iterator. It has 5 typedefs.
	//These 5 typedefs provide standard way to access properties of iterator, regardless of iterator type.
	//Template struct is specialized for ptrs and const_ptrs.
	template<class Iterator>
	struct iterator_traits {
		typedef typename Iterator::difference_type			difference_type;		//diff between 2 iterators
		typedef typename Iterator::value_type				value_type;				//type of element
		typedef typename Iterator::pointer					pointer;				//return type of operator->()
		typedef typename Iterator::reference				reference;				//return type of operator*()
		typedef typename Iterator::iterator_category		iterator_category;		//indicatin what opers itr supports

	};


	/////////////////////////////////////////////////////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////////////////////////////////////////////////////
	//***ITERATOR TRAITS SPECIALIZATION***///////////////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////////////////////////////////////////////////////
	template<typename T>
	struct iterator_traits<T*> {	//specializations for pointers
		typedef		ptrdiff_t						difference_type;	//diff is reprsntd by stl type ptrdiff_t
		typedef 	T								value_type;
		typedef		T*								pointer;
		typedef		T&								reference;
		typedef		random_access_iterator_tag		iterator_category;
	};

	/////////////////////////////////////////////////////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////////////////////////////////////////////////////
	//***ITERATOR TRAITS CONST SPECIALIZATION***/////////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////////////////////////////////////////////////////
	template <typename T>
	struct iterator_traits<const T*> {
		typedef		ptrdiff_t						difference_type;
		typedef		T								value_type;
		typedef		const T*						pointer;
		typedef		const T&						reference;
		typedef		ft::random_access_iterator_tag	iterator_category;
	};
	

}

#endif